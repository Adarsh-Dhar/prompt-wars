/**
 * Property-based tests for interface validation
 * Feature: rekto-rich-agent, Property 1: Trading decision display completeness
 * Validates: Requirements 1.2, 1.3
 */

import * as fc from 'fast-check';
import { TradingDecision, ChainOfThought, PredictionMarket, UserBet, DegenAgent, PaymentVerification } from '../types';

describe('Interface Validation Property Tests', () => {
  
  // Generators for property-based testing
  const tradingDecisionGenerator = fc.record({
    id: fc.uuid(),
    tokenSymbol: fc.string({ minLength: 1, maxLength: 10 }).filter(s => /^[A-Z]+$/.test(s)),
    decision: fc.constantFrom('LONG', 'SHORT'),
    confidence: fc.integer({ min: 0, max: 100 }),
    timestamp: fc.date(),
    currentPrice: fc.float({ min: 0.000001, max: 1000000 }),
    chainOfThought: fc.option(fc.string({ minLength: 10 })),
    isUnlocked: fc.boolean(),
    marketId: fc.option(fc.uuid())
  });

  const chainOfThoughtGenerator = fc.record({
    decisionId: fc.uuid(),
    reasoning: fc.string({ minLength: 10 }),
    marketAnalysis: fc.string({ minLength: 10 }),
    riskAssessment: fc.string({ minLength: 10 }),
    degenCommentary: fc.string({ minLength: 10 }),
    priceTargets: fc.record({
      bullish: fc.float({ min: 0.000001, max: 1000000 }),
      bearish: fc.float({ min: 0.000001, max: 1000000 })
    })
  });

  const predictionMarketGenerator = fc.record({
    id: fc.uuid(),
    decisionId: fc.uuid(),
    totalPool: fc.float({ min: 0, max: 1000000 }),
    winBets: fc.float({ min: 0, max: 1000000 }),
    lossBets: fc.float({ min: 0, max: 1000000 }),
    resolutionTime: fc.date(),
    isResolved: fc.boolean(),
    outcome: fc.option(fc.constantFrom('WIN', 'LOSS'))
  });

  const userBetGenerator = fc.record({
    id: fc.uuid(),
    userId: fc.uuid(),
    marketId: fc.uuid(),
    prediction: fc.constantFrom('WIN', 'LOSS'),
    amount: fc.float({ min: 0.01, max: 1000000 }),
    timestamp: fc.date(),
    isWinning: fc.option(fc.boolean()),
    payout: fc.option(fc.float({ min: 0, max: 1000000 }))
  });

  const degenAgentGenerator = fc.record({
    personality: fc.record({
      riskTolerance: fc.constantFrom('EXTREME', 'HIGH', 'MODERATE'),
      tradingStyle: fc.constantFrom('MOMENTUM', 'CONTRARIAN', 'HYPE_DRIVEN'),
      slangIntensity: fc.integer({ min: 1, max: 10 })
    }),
    performance: fc.record({
      totalPredictions: fc.integer({ min: 0, max: 10000 }),
      correctPredictions: fc.integer({ min: 0, max: 10000 }),
      averageReturn: fc.float({ min: -100, max: 1000 }),
      winStreak: fc.integer({ min: 0, max: 100 })
    })
  });

  const paymentVerificationGenerator = fc.record({
    transactionSignature: fc.string({ minLength: 64, maxLength: 88 }),
    amount: fc.float({ min: 0.01, max: 1000000 }),
    sender: fc.string({ minLength: 32, maxLength: 44 }),
    recipient: fc.string({ minLength: 32, maxLength: 44 }),
    timestamp: fc.date(),
    isVerified: fc.boolean(),
    contentId: fc.uuid()
  });

  /**
   * Property 1: Trading decision display completeness
   * For any trading decision generated by the Degen_Agent, the display should include 
   * token symbol, current price, timestamp, decision type (LONG/SHORT), and blurred reasoning content
   */
  test('Property 1: Trading decision display completeness', () => {
    fc.assert(
      fc.property(tradingDecisionGenerator, (decision: TradingDecision) => {
        // Verify all required display fields are present and valid
        expect(decision.tokenSymbol).toBeDefined();
        expect(decision.tokenSymbol.length).toBeGreaterThan(0);
        expect(decision.currentPrice).toBeGreaterThan(0);
        expect(decision.timestamp).toBeInstanceOf(Date);
        expect(['LONG', 'SHORT']).toContain(decision.decision);
        expect(decision.confidence).toBeGreaterThanOrEqual(0);
        expect(decision.confidence).toBeLessThanOrEqual(100);
        expect(typeof decision.isUnlocked).toBe('boolean');
        
        // If chainOfThought is present, it should be a string
        if (decision.chainOfThought !== undefined) {
          expect(typeof decision.chainOfThought).toBe('string');
        }
        
        // If marketId is present, it should be a valid string
        if (decision.marketId !== undefined) {
          expect(typeof decision.marketId).toBe('string');
          expect(decision.marketId.length).toBeGreaterThan(0);
        }
        
        return true;
      }),
      { numRuns: 100 }
    );
  });

  test('ChainOfThought interface validation', () => {
    fc.assert(
      fc.property(chainOfThoughtGenerator, (cot: ChainOfThought) => {
        expect(cot.decisionId).toBeDefined();
        expect(cot.reasoning.length).toBeGreaterThan(0);
        expect(cot.marketAnalysis.length).toBeGreaterThan(0);
        expect(cot.riskAssessment.length).toBeGreaterThan(0);
        expect(cot.degenCommentary.length).toBeGreaterThan(0);
        expect(cot.priceTargets.bullish).toBeGreaterThan(0);
        expect(cot.priceTargets.bearish).toBeGreaterThan(0);
        return true;
      }),
      { numRuns: 100 }
    );
  });

  test('PredictionMarket interface validation', () => {
    fc.assert(
      fc.property(predictionMarketGenerator, (market: PredictionMarket) => {
        expect(market.id).toBeDefined();
        expect(market.decisionId).toBeDefined();
        expect(market.totalPool).toBeGreaterThanOrEqual(0);
        expect(market.winBets).toBeGreaterThanOrEqual(0);
        expect(market.lossBets).toBeGreaterThanOrEqual(0);
        expect(market.resolutionTime).toBeInstanceOf(Date);
        expect(typeof market.isResolved).toBe('boolean');
        
        if (market.outcome !== undefined) {
          expect(['WIN', 'LOSS']).toContain(market.outcome);
        }
        
        return true;
      }),
      { numRuns: 100 }
    );
  });

  test('UserBet interface validation', () => {
    fc.assert(
      fc.property(userBetGenerator, (bet: UserBet) => {
        expect(bet.id).toBeDefined();
        expect(bet.userId).toBeDefined();
        expect(bet.marketId).toBeDefined();
        expect(['WIN', 'LOSS']).toContain(bet.prediction);
        expect(bet.amount).toBeGreaterThan(0);
        expect(bet.timestamp).toBeInstanceOf(Date);
        
        if (bet.isWinning !== undefined) {
          expect(typeof bet.isWinning).toBe('boolean');
        }
        
        if (bet.payout !== undefined) {
          expect(bet.payout).toBeGreaterThanOrEqual(0);
        }
        
        return true;
      }),
      { numRuns: 100 }
    );
  });

  test('DegenAgent interface validation', () => {
    fc.assert(
      fc.property(degenAgentGenerator, (agent: DegenAgent) => {
        expect(['EXTREME', 'HIGH', 'MODERATE']).toContain(agent.personality.riskTolerance);
        expect(['MOMENTUM', 'CONTRARIAN', 'HYPE_DRIVEN']).toContain(agent.personality.tradingStyle);
        expect(agent.personality.slangIntensity).toBeGreaterThanOrEqual(1);
        expect(agent.personality.slangIntensity).toBeLessThanOrEqual(10);
        
        expect(agent.performance.totalPredictions).toBeGreaterThanOrEqual(0);
        expect(agent.performance.correctPredictions).toBeGreaterThanOrEqual(0);
        expect(agent.performance.correctPredictions).toBeLessThanOrEqual(agent.performance.totalPredictions);
        expect(agent.performance.winStreak).toBeGreaterThanOrEqual(0);
        
        return true;
      }),
      { numRuns: 100 }
    );
  });

  test('PaymentVerification interface validation', () => {
    fc.assert(
      fc.property(paymentVerificationGenerator, (payment: PaymentVerification) => {
        expect(payment.transactionSignature).toBeDefined();
        expect(payment.transactionSignature.length).toBeGreaterThanOrEqual(64);
        expect(payment.amount).toBeGreaterThan(0);
        expect(payment.sender).toBeDefined();
        expect(payment.recipient).toBeDefined();
        expect(payment.timestamp).toBeInstanceOf(Date);
        expect(typeof payment.isVerified).toBe('boolean');
        expect(payment.contentId).toBeDefined();
        
        return true;
      }),
      { numRuns: 100 }
    );
  });
});